{
    "id": "status-pages",
    "name": "Status Pages",
    "version": "1.5.2",
    "ktor_version": "1.4.0",
    "short_description": "Allow to respond to thrown exceptions.",
    "github": "https://github.com/ktorio/ktor/blob/7e78e715cec3ff039cd628f8ff8ce875c35cde4c/ktor-server/ktor-server-core/jvm/src/io/ktor/features/StatusPages.kt",
    "copyright": "Apache 2.0",
    "vendor": {
        "name": "Ktor",
        "url": "https://ktor.io/"
    },
    "group": "Routing",
    "required_feature_ids": [
        "routing"
    ],
    "install_recipe": {
        "imports": [
            "io.ktor.features.*"
        ],
        "install_block": "",
        "templates": [
            {
                "position": "in_routing",
                "text": "install(StatusPages) {\n    exception<AuthenticationException> { cause ->\n        call.respond(HttpStatusCode.Unauthorized)\n    }\n    exception<AuthorizationException> { cause ->\n        call.respond(HttpStatusCode.Forbidden)\n    }\n\n}"
            },
            {
                "position": "outside_app",
                "text": "class AuthenticationException : RuntimeException()\nclass AuthorizationException : RuntimeException()"
            }
        ]
    },
    "dependencies": [
        {
            "group": "io.ktor",
            "artifact": "ktor-server-host-common",
            "version": "$ktor_version"
        }
    ],
    "documentation": {
        "description": "The `StatusPages` plugin allows Ktor applications to respond appropriately to any failure state.",
        "usage": "## Installation\nThis plugin is installed using the standard application configuration:\n\n```kotlin\nfun Application.main() {\n    install(StatusPages)\n}\n```\n## Exceptions\nThe exception configuration can provide simple interception patterns for calls that result in a thrown exception. In the most basic case, a `500` HTTP status code can be configured for any exceptions.\n\n```kotlin\ninstall(StatusPages) {\n    exception<Throwable> { cause ->\n        call.respond(HttpStatusCode.InternalServerError)\n    }\n}\n```\nMore specific responses can allow for more complex user interactions.\n\n```kotlin\ninstall(StatusPages) {\n    exception<AuthenticationException> { cause ->\n        call.respond(HttpStatusCode.Unauthorized)\n    }\n    exception<AuthorizationException> { cause ->\n        call.respond(HttpStatusCode.Forbidden)\n    }\n}\n```\nThese customizations can work well when paired with custom status code responses, e.g. providing a login page when a user has not authenticated.\n\nEach call is only caught by a single exception handler, the closest exception on the object graph from the thrown exception. When multiple exceptions within the same object hierarchy are handled, only a single one will be executed.\n```kotlin\ninstall(StatusPages) {\n    exception<IllegalStateException> { cause ->\n        fail(\"will not reach here\")\n    }\n    exception<ClosedFileSystemException> {\n        throw IllegalStateException()\n    }\n}\nintercept(ApplicationCallPipeline.Fallback) {\n    throw ClosedFileSystemException()\n}\n```\nSingle handling also implies that recursive call stacks are avoided. For example, this configuration would result in the created IllegalStateException propagating to the client.\n\n```kotlin\ninstall(StatusPages) {\n    exception<IllegalStateException> { cause ->\n        throw IllegalStateException(\"\")\n    }\n}\n```\n## Logging Exceptions\nIt is important to note that adding the handlers above will \"swallow\" the exceptions generated by your routes. In order to log the actual errors generated, you can either log the `cause` manually, or simply re-throw it as shown below:\n\n```kotlin\ninstall(StatusPages) {\n    exception<Throwable> { cause ->\n        call.respond(HttpStatusCode.InternalServerError, \"Internal Server Error\")\n        throw cause\n    }\n}\n```\n## Status\nThe `status` configuration provides a custom actions for status responses from within the application. Below is a basic configuration that provides information about the HTTP status code within the response text.\n\n```kotlin\ninstall(StatusPages) {\n    status(HttpStatusCode.NotFound) {\n        call.respond(TextContent(\"${it.value} ${it.description}\", ContentType.Text.Plain.withCharset(Charsets.UTF_8), it))\n    }\n}\n```\n## StatusFile\nWhile the `status` configuration provides customizable actions on the response object, the more common solution is to provide an error HTML page that visitors will see on an error or authorization failure. The `statusFile` configuration provides that type of functionality.\n\n```kotlin\ninstall(StatusPages) {\n    statusFile(HttpStatusCode.NotFound, HttpStatusCode.Unauthorized, filePattern = \"error#.html\")\n}\n```\nThis will resolve two resources from the classpath.\n* On a `404`, it will return `error404.html`.\n* On a `401`, it will return `error401.html`.\n\nThe `statusFile` configuration replaces any `#` character with the value of the status code within the list of configured statuses.\n\n## Redirections using StatusPages\nWhen doing redirections by executing `call.respondRedirect(\"/moved/here\", permanent = true)`, the rest of the callee function is executed. So when doing redirections inside guard clauses, you have to return the function.\n\n```kotlin\nrouting {\n    get(\"/\") {\n        if (condition) {\n            return@get call.respondRedirect(\"/invalid\", permanent = false)\n        }\n        call.respondText(\"Normal response\")\n    }\n}\n```\nOther frameworks, use exceptions on redirect, so the normal flow is broken and you can execute redirections in guard clauses or subfunctions without having to worry about returning in all the subfunction chain. You can use the StatusPages plugin to simulate this:\n\n```kotlin\nfun Application.module() {\n    install(StatusPages) {\n        exception<HttpRedirectException> { e ->\n            call.respondRedirect(e.location, permanent = e.permanent)\n        }\n    }\n    routing {\n        get(\"/\") {\n            if (condition) {\n                redirect(\"/invalid\", permanent = false)\n            }\n            call.respondText(\"Normal response\")\n        }\n    }\n}\n\nclass HttpRedirectException(val location: String, val permanent: Boolean = false) : RuntimeException()\nfun redirect(location: String, permanent: Boolean = false): Nothing = throw HttpRedirectException(location, permanent)\n```\n",
        "options": "* `exceptions` - Configures response based on mapped exception classes\n* `status` - Configures response to status code value\n* `statusFile` - Configures standard file response from classpath"
    }
}